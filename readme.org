* Advent Of Code - 2019
I'm trying to solve these problems as a practice for prolog programming.
** Day1
#+BEGIN_SRC prolog :exports both
  :- consult("src/day1.pl").
  :- main("inputs/day1", X), print(X).
#+END_SRC

#+RESULTS:
: 4943969
** Day2
#+BEGIN_SRC prolog :exports both
  :- consult("src/day2.pl").
  %% Part1 1202 program
  :- output("inputs/day2", 12, 2, X), print(X), nl.
  %% Part2 finding input program
  :- find_inputs("inputs/day2", 19690720, N, V), Ans is N*100 + V, print(Ans), nl.
#+END_SRC

#+RESULTS:
| 3716293 |
|    6429 |
** Day3
Wasted a bit of time trying out a brute force solution. Finally tried out just intersecting lines of two wires rather than each point. A language with arrays would have lead to a more straight forward simulation. Prolog forced me to get more creative.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day3.pl").
  :- main("inputs/day3", X, Y), writef('Part1: (%w), Part2: %t\n', [X, Y]).
#+END_SRC

#+RESULTS:
| Part1: (860 | 0) | Part2: 9238 |
** Day4
This constraint problem was pretty simple for Prolog to search through. Took just enough time to type it in.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day4.pl").
  :- part1(X), part2(Y), writef('Part1 : %t, Part2 : %t\n', [X, Y]).
#+END_SRC

#+RESULTS:
| Part1 : 2779 | Part2 : 1972 |
** Day5
*** Part1
Took awhile to wrestle everything into place. The output codes for all the tests are supposed to comeback zero, but my first one returns 3. The answer for diagnostics code is correct. Where is the bug?
#+BEGIN_SRC prolog :exports both
  :- consult("src/day5.pl").
  :- part1("inputs/day5", X), print(X),nl.
#+END_SRC

#+RESULTS:
| [3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 13787043] |
*** Part2
Now we have jumps and comparison operators making this a full-fledged computer.
