* Advent Of Code - 2019
I'm trying to solve these problems as a practice for prolog programming.
** Day1
#+BEGIN_SRC prolog :exports both
  :- consult("src/day1.pl").
  :- main("inputs/day1", X), print(X).
#+END_SRC

#+RESULTS:
: 4943969
** Day2
#+BEGIN_SRC prolog :exports both
  :- consult("src/day2.pl").
  %% Part1 1202 program
  :- output("inputs/day2", 12, 2, X), print(X), nl.
  %% Part2 finding input program
  :- find_inputs("inputs/day2", 19690720, N, V), Ans is N*100 + V, print(Ans), nl.
#+END_SRC

#+RESULTS:
| 3716293 |
|    6429 |
** Day3
Wasted a bit of time trying out a brute force solution. Finally tried out just intersecting lines of two wires rather than each point. A language with arrays would have lead to a more straight forward simulation. Prolog forced me to get more creative.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day3.pl").
  :- main("inputs/day3", X, Y), writef('Part1: (%w), Part2: %t\n', [X, Y]).
#+END_SRC

#+RESULTS:
| Part1: (860 | 0) | Part2: 9238 |
** Day4
This constraint problem was pretty simple for Prolog to search through. Took just enough time to type it in.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day4.pl").
  :- part1(X), part2(Y), writef('Part1 : %t, Part2 : %t\n', [X, Y]).
#+END_SRC

#+RESULTS:
| Part1 : 2779 | Part2 : 1972 |
** Day5
Some bugs were ironed out during part2 debugging. Sometimes I am confused when ordering the conjunctive clauses which results in un-instantiated errors.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day5.pl").
  :- test_diagnostic("inputs/day5", 1, Os), last(Os, X), print(X),nl.
  :- test_diagnostic("inputs/day5", 5, [X]), print(X),nl.
#+END_SRC

#+RESULTS:


** Day6
I drew the graph using xdot just to [[file:resources/day6.png][visualize]] how complicated the data was.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day6.pl").
  :- F = "inputs/day6", part1(F, A1), part2(F, A2), format("~a  ~a", [A1, A2]).
#+END_SRC

#+RESULTS:
: 162816  304
** Day7
Part 1 was done without changing any code from day5 problem. Part 2 requires some changes in IO code of the program execution. I need introduce a waiting-on-input status in the run_program_ function.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day7.pl").
  :- part7_1("inputs/day7", X), print(X), nl.
#+END_SRC

#+RESULTS:
: 929800
Part 2 required some effort to sync IO of all instances of the programs. Most of my time was wasted at a bug in step_program halt case, where I forgot to set the new instruction pointer to the old one and thus missed the infinite loop caused by mis-ordering the halt, output cases in run_all_amplifiers.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day7.pl").
  :- part7_2("inputs/day7", X), print(X), nl.
#+END_SRC

#+RESULTS:
: 15432220


** Day 8
This was an easy problem. I only stumbled a bit to define the zip function to layer the image. 
#+BEGIN_SRC prolog :exports both
  :- consult("src/day8.pl").
  :- part1("inputs/day8", (25,6), X), print(X),nl.
  :- Fname="resources/day8.pbm", part2((25,6), "inputs/day8", Fname),
     format("[[file:~s]]~n", Fname).
#+END_SRC

#+RESULTS:
|                    2562 |
| [[file:resources/day8.pbm]] |

*** TODO Infinite solutions bug
There is one bug in my solution: prolog gives me the same solution infinite times. So there must be a closed loop in one of my definitions.

** Day 9
I'm going to rewrite the intcode computer as a seperate module. I should have done it on the day7 problem itself but was too lazy to bother learning modules. Now it seems this will be the common base for future problems too.
*** Part 1
After wrangling quite a bit of quick and dirty code, the module intcode is ready and functional. I tested it with day5 and day7 problems before trying out day9 and solved quite a few bugs along the way.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day9.pl").
  :- part9_1("inputs/day9", [A]), print(A), nl.
#+END_SRC

#+RESULTS:
: 2351176124
*** TODO Part 2 - INCOMPLETE
The program is looping a lot, likely doing some inefficient computation. I need to figure out what it is trying to do and then compute it efficiently for my answer. For now it seems to be looping around 920-960 addresses after 20-30 steps. Instead of getting dirty and parsing the code manually, I am taking the long way home by writing a parser that will make things more clear. Let us see how this goes.
Got parsing done. Need to analyze later(It is quite cumbersome).
#+BEGIN_SRC prolog :exports both
  :- consult("src/intcode.pl").
  :- get_program("inputs/day9", Prog),
     intcode:run_program_nsteps((0, Prog, 0), 2, (NewIP, NProg, NB),
				O, 1000, (1000, X, BD)).
#+END_SRC

#+RESULTS:
** Day 10
I got a bad solution working for all the examples. The time complexity is probably n^3 the size of the initial map. Small examples take less than a second but, final example takes 138 seconds.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day10.pl").
  :- read_map("inputs/day10test3", M, S), find_asteroids_views(M, S, A),
     find_max_asteroid(A, Ans), print(Ans).
#+END_SRC

#+RESULTS:
| (3 | 6) | 41 |
The actual input will probably run for hours(done, it did run around 1hr22min). I need to find a more efficient algorithm(or implementation, my code is quite dirty).
#+BEGIN_EXAMPLE
4,377,984,637 inferences, 4928.755 CPU in 4963.529 seconds (99% CPU, 888254 Lips)
Ans = ((29, 26), 303) 
#+END_EXAMPLE
***  Part 2 lasers
Took a while to sort laser rays.
#+BEGIN_SRC prolog :exports both
  :- consult("src/day10.pl").
  :- part2("inputs/day10", (29, 26), (X, Y)), A is 100*Y + X, print(A).
#+END_SRC

 #+RESULTS:
 : 408
